<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX061D1EE4350E40638DF91737F333AE2E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngine-StateShards</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXA19065CC8B2E4D78B566B7C15A0599E4">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
				<string name="ScriptGuid">{FC4B8716-6243-42AC-BF2E-2E8AAADAF29E}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">APIConsumer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX385DC7F0329C473CA4832438E6B966AC">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local apiConsumer = require(script.Parent.APIConsumer)
local warnLogger = require(script.Parent.Slogger)
warnLogger.init{postInit = table.freeze, logFunc = warn}
local glut = require(script.Parent.GLUt)

type APIReference = apiConsumer.APIReference

local warn = warnLogger.new("StateShards")
glut.configure{ warn = warn }

local hookName = nil

local StateShards = {}

local SHARD_ITEM_PATTERN = "%[([%a_][%w_]+)%]"
local SHARD_GOTO_PATTERN = "GOTO[ \t]+" .. SHARD_ITEM_PATTERN
local SHARD_GOTO_PATTERN2 = "goto[ \t]+" .. SHARD_ITEM_PATTERN
local SHARD_LABEL_PATTERN = ':' .. SHARD_ITEM_PATTERN
local SHARD_LOCAL_PATTERN = '#' .. SHARD_ITEM_PATTERN

local function expandShard(shard, as)
	local gotosExpanded = string.gsub(
		shard,
		SHARD_GOTO_PATTERN,
		function(s)
			local gotoName = (as == nil) and s or as
			return "GOTO " .. gotoName
		end
	)
	gotosExpanded = string.gsub(
		gotosExpanded,
		SHARD_GOTO_PATTERN2,
		function(s)
			local gotoName = (as == nil) and s or as
			return "goto " .. gotoName
		end
	)
	local localsExpanded = string.gsub(
		gotosExpanded,
		SHARD_LOCAL_PATTERN,
		function(s)
			local localName = (as == nil) and s or as
			return '#' .. localName
		end
	)
	return string.gsub(
		localsExpanded,
		SHARD_LABEL_PATTERN,
		function(s)
			local labelName = (as == nil) and s or as
			return ':' .. labelName
		end
	)
end

local function includeShard(warn, shards, shardName)
	local warn = warn.specialize(`Script include {shardName} invalid`)
	local result, failReason = StateShards.FindShard(shards, shardName)
	if result == nil then warn(failReason) return "" end
	return expandShard(result)
end

local function includeShardAs(warn, shards, shardName, shardAs)
	local warn = warn.specialize(`Script include {shardName} invalid`)
	local result, failReason = StateShards.FindShard(shards, shardName)
	if result == nil then warn(failReason) return "" end
	return expandShard(result, shardAs)
end

local preprocessorCommands = {
	["#include[ \t]+<([%a_][%w_%./\\]+)>[%s]*[\r\n]"] = includeShard,
	["#INCLUDE[ \t]+<([%a_][%w_%./\\]+)>[%s]*[\r\n]"] = includeShard,
	["#include[ \t]+<([%a_][%w_%./\\]+)>[ \t]+as[ \t]+<:?([%a_][%w_]+)>[%s]*[\r\n]"] = includeShardAs,
	["#INCLUDE[ \t]+<([%a_][%w_%./\\]+)>[ \t]+AS[ \t]+<:?([%a_][%w_]+)>[%s]*[\r\n]"] = includeShardAs
}

local function isStateComponentScript(pTarget)
	if not pTarget:IsA("BoolValue") then return false end
	local targetType = pTarget:GetAttribute("Type")
	local typeValid = type(targetType) == "string"
	if not typeValid then
		return false, "Type attribute is of non-string datatype"
	end
	local isStateScript = targetType == "StateScript"
	if not isStateScript then return false end
	local stateScriptValid = type(pTarget:GetAttribute("ScriptSource")) == "string"
	return (isStateScript and stateScriptValid), (not stateScriptValid) and "ScriptSource attribute is of non-string datatype" or nil
end

local function isPropScript(pTarget)
	if not pTarget:IsA("Part") then return false end
	if not (pTarget.Name == "StateScriptPart") then return false end
	local sourceValid = type(pTarget:GetAttribute("ScriptSource")) == "string"
	return sourceValid, (not sourceValid) and "ScriptSource attribute is of non-string datatype" or nil
end

function StateShards.OnAPILoaded(api: APIReference, shardState)
	hookName = hookName or api.GetRegistrantFactory("Sprix", "StateShards")
	local hookData = {}
	shardState[1] = api.AddHook("PreSerialize", hookName("PreSerialize"), StateShards.OnPreSerialize, hookData)
end

function StateShards.OnAPIUnloaded(api: APIReference, shardState)
	for _, token in ipairs(shardState) do
		api.RemoveHook(token)
	end
end

function StateShards.OnPreSerialize(callbackState, invokeState, mission: Folder)
	local warn = warn.specialize("OnPreSerialize")
	
	local first = true
	repeat
		if not first then coroutine.yield() end
		local _, prefabPresent = invokeState.Get("Sprix_PrefabSystem_PreSerialize_Present")
		local prefabSuccess, prefabDone = invokeState.Get("Sprix_PrefabSystem_PreSerialize", "Done")
		local prefabDone = (not prefabPresent) or (prefabSuccess and prefabDone)
		
		local _, continentPresent = invokeState.Get("Sprix_ContinentController_PreSerialize_Present")
		local continentSuccess, continentDone = invokeState.Get("Sprix_ContinentController_PreSerialize", "Done")
		local continentDone = (not continentPresent) or (continentSuccess and continentDone)
		first = false
	until prefabDone and continentDone
	
	local shardFolder = mission:FindFirstChild("StateScriptShards")
	if not shardFolder then return end
	
	local shards = StateShards.ConstructShardTable(shardFolder)
	
	local stateComponents = mission:FindFirstChild("StateComponents")
	if stateComponents then
		StateShards.RunPreprocessor(shards, stateComponents, isStateComponentScript)
	end
	
	local stateComponentTemplates = mission:FindFirstChild("StateComponentTemplates")
	if stateComponentTemplates then
		StateShards.RunPreprocessor(shards, stateComponentTemplates, isStateComponentScript)
	end
	
	local props = mission:FindFirstChild("Props")
	if props then
		StateShards.RunPreprocessor(shards, props, isPropScript)
	end
	
	print("StateShards : Successfully preprocessed all StateScripts/StateScriptParts")
	shardFolder:Destroy()
end

function StateShards.ConstructShardTable(shardRoot, tbl)
	local warn = warn.specialize("ConstructShardTable")
	tbl = glut.default(tbl, {})
	for _, c in shardRoot:GetChildren() do
		local shardStr = ""
		if c:IsA("Folder") then
			tbl[c.Name] = StateShards.ConstructShardTable(c)
			continue
		elseif c:IsA("LocalScript") then
			warn(c, `Only Script/ModuleScript instances are currently officially supported, behaviour of LocalScripts is reserved & may change in future`, "Shard will be treated like a Script")
			shardStr = c.Source
		elseif c:IsA("ModuleScript") then
			shardStr = require(c)
			if type(shardStr) ~= "string" and type(shardStr) ~= "table" then
				warn(`ModuleScript Shard {c} returned non-string, non-table value`, "Shard will be ignored!")
				continue
			end
		elseif c:IsA("Script") then
			shardStr = c.Source
		else
			warn(`Instance {c} found in {shardRoot} is of unsupported type {c.ClassName}`, "Instance will be ignored!")
			continue
		end
		
		if type(shardStr) == "table" then
			local shardTable = shardStr
			shardStr = shardTable.Source or shardTable.source
			if type(shardTable.DefaultOverride) == "string" then
				local override = glut.str_trimend(glut.str_trimstart(shardTable.DefaultOverride, '%['), '%]')
				shardStr = expandShard(shardStr, '[' .. override .. ']')
			end
		end
		
		if not glut.str_has_match(shardStr, SHARD_LABEL_PATTERN) then
			warn(`StateScriptShard {c} is invalid - no shard labels found!`, "Shard will be ignored!")
			continue
		end
		
		tbl[c.Name] = glut.str_trim(shardStr) .. '\n'
	end
	return tbl
end

function StateShards.FindShard(shardTable, shardPath)
	local separator = glut.str_has_match(shardPath, '/') and '/' or glut.str_has_match(shardPath, '\\') and '\\' or glut.str_has_match(shardPath, '%.') and '.' or nil
	if not separator then
		local result = shardTable[shardPath]
		if type(result) ~= "string" then return nil, `Path pointed to invalid data` end
		return result
	end
	local shardPathSplit = glut.str_split(shardPath, separator)
	local success, shard, failKey = glut.tbl_deepget(shardTable, false, unpack(shardPathSplit))
	if not success and failKey then
		return nil, `Path element {failKey} pointed to invalid data`
	elseif not success then
		return nil, "Path pointed to invalid data"
	end
	
	if type(shard) ~= "string" then
		return nil, `Path led to a folder!`
	end
	
	return shard
end

function StateShards.RunPreprocessor(shards, root, targetId)
	local warn = warn.specialize("RunPreprocessor", root.Name)
	for _, target in ipairs(root:GetDescendants()) do
		local warn = warn.specialize(`StateComponent {target} is invalid`, "Component will be ignored")
		local isTarget, invalidReason = targetId(target)
		if not isTarget and not invalidReason then continue end
		if invalidReason then warn(invalidReason) continue end
		
		local scriptSource = target:GetAttribute("ScriptSource")
		local newSource = scriptSource
		for pattern, handler in pairs(preprocessorCommands) do
			newSource = string.gsub(newSource, pattern, function(...) return handler(warn, shards, ...) end)
		end
		target:SetAttribute("ScriptSource", newSource)
	end
end

apiConsumer.DoAPILoop(plugin, "InfiltrationEngine-StateShards", StateShards.OnAPILoaded, StateShards.OnAPIUnloaded)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{54CA1310-BD51-4B26-9750-641CD6834F68}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX8EB64A8E19664566879FF08E201C2A03">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	Slogger, yet another minimal Lua logging module
	Log function + post-init function are configurable, for dealing with the slog that is lua version compatibility
	
	Tested to be compatible with Lua5.1
	Presumed compatible with Lua5.2-5.5/Luajit/Luau
	
	© Sprixitite, 2025
]]

local slogger = {}

local sloggerCfg = {
	postInit = function(tbl) return tbl end,
	logFunc = print
}

local function varargs(...)
	local argCount = select('#', ...)
	local argTbl = { ... }
	local i = 0
	return function()
		i = i + 1
		if i <= argCount then return i, argTbl[i], argCount end
	end, argTbl
end

function slogger.new(...)
	local loggerPrefix = ""
	local varargsIter, argsTbl = varargs(...)
	
	for i, arg in varargsIter do
		loggerPrefix = loggerPrefix .. tostring(arg) .. " : "
	end
	
	local doWarn = function(tbl, ...)
		local finalMsg = ""
		
		for i, arg, argCount in varargs(...) do
			finalMsg = finalMsg .. tostring(arg)
			if i ~= argCount then
				finalMsg = finalMsg .. " : "
			end
		end
		
		sloggerCfg.logFunc(loggerPrefix .. finalMsg)
	end
	
	local specialize = function(...)
		return slogger.new(unpack(argsTbl), ...)
	end
	
	local newLogger = setmetatable({ specialize = specialize }, {__call = doWarn})
	return sloggerCfg.postInit(newLogger)
end

function slogger.init(cfg)
	for k, v in pairs(cfg) do
		if type(sloggerCfg[k]) == type(v) then
			sloggerCfg[k] = v
		end
	end
	return slogger
end

return slogger]]></ProtectedString>
				<string name="ScriptGuid">{52E65CB1-74BE-47EC-B16B-31596F9F3888}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Slogger</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX25E3370CCC714C9B8B65A4A16E85E33A">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	GLUt // GoodLuaUtilities // Lua5.1 utilities module
	
	© Sprixitite, 2025
]]

local GLUt = {}

local GLUtCfg = {
	print = print,
	warn  = function(...) print("WARNING", ...) end,
	error = error,
	type  = type
}

local patternSpecChars = { '(', ')', '.', '%', '+', '-', '*', '?', '[', ']', '^', '$' }

function GLUt.configure(tbl)
	for k, v in pairs(tbl) do
		if GLUtCfg[k] ~= nil then
			GLUtCfg[k] = v
		else
			GLUtCfg.warn("Attempt to set invalid GLUtCfg Key \"" .. tostring(k) .. "\"")
		end
	end
end

function GLUt.default(arg, default)
	return (arg == nil) and default or arg
end

function GLUt.default_exec(arg, fn)
	return (arg == nil) and fn() or arg
end

function GLUt.default_typed(arg, default, argName, funcName)
	local argType = GLUtCfg.type(arg)
	local defaultType = GLUtCfg.type(default)
	if argType == defaultType then return arg end
	if argType == "nil" then return default end
	GLUt.type_warn(argName, funcName, defaultType, argType)
	return default
end

function GLUt.type_warn(argName, funcName, expected, got, isErr)
	if argName == nil or expected == got then return end
	isErr = GLUt.default(isErr, false)

	local logFun = isErr and GLUtCfg.error or GLUtCfg.warn

	local warnStart = GLUt.type_is(funcName, "string") and (funcName .. ": expected arg \"") or "Expected arg \""
	logFun(warnStart .. argName .. "\" of type \"" .. expected .. "\" got type \"" .. got .. "\"!")
	logFun("Traceback: " .. debug.traceback())
end

function GLUt.type_check(arg, expected, argName, funcName, isErr)
	isErr = GLUt.default(isErr, false)
	local argType = GLUtCfg.type(arg)

	expected = string.gsub(expected, '?', "|nil")
	for _, validType in pairs(GLUt.str_split(expected, '|')) do
		if validType == argType then return true end
	end

	GLUt.type_warn(argName, funcName, expected, argType, isErr)

	return false
end

function GLUt.type_is(a1, t)
	return GLUtCfg.type(a1) == t
end

function GLUt.type_eq(a1, a2)
	return GLUtCfg.type(a1) == GLUtCfg.type(a2)
end

function GLUt.vararg_capture(...)
	local n = select('#', ...)
	return n, { ... }
end

function GLUt.vararg_iter(...)
	local n, t = GLUt.vararg_capture(...)
	local i = 0
	return function()
		i = i + 1
		if i <= n then return i, t[i], n end
	end, t
end

function GLUt.str_split(str, separator)
	str = str .. separator
	separator = GLUt.str_escape_pattern(separator)

	local substrs = {}
	for substr in string.gmatch(str, "(.-)" .. separator) do
		substrs[#substrs+1] = substr
	end
	return substrs
end

function GLUt.str_has_match(str, pattern)
	return string.match(str, pattern) ~= nil
end

function GLUt.str_escape_pattern(str)
	local escaped = str
	for _, specChar in ipairs(patternSpecChars) do
		local escapedSpec = '%' .. specChar
		escaped = string.gsub(escaped, escapedSpec, (specChar == '%') and "%%" or '%' .. escapedSpec)
	end
	return escaped
end

function GLUt.str_double_substr(str, substr)
	local safe = GLUt.str_escape_pattern(substr)
	return string.gsub(str, safe, safe .. safe)
end

function GLUt.str_isempty(str)
	return string.match(str, "^%s$") ~= nil
end

function GLUt.str_chariter(str)
	local n = #str
	local i = 0
	return function()
		i = i + 1
		if i <= n then return GLUt.str_getchar(str, i) end
	end
end

function GLUt.str_trim(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return GLUt.str_trimend(GLUt.str_trimstart(str, pattern), pattern)
end

function GLUt.str_trimstart(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return string.gsub(str, '^' .. pattern, "")
end

function GLUt.str_trimend(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return string.gsub(str, pattern .. '$', "")
end

function GLUt.str_getchar(str, i)
	return string.sub(str, i, i)
end

local unidentified = -1
function GLUt.str_runlua(source, fenv, chunkName)
	chunkName = GLUt.default_exec(chunkName, function()
		unidentified = unidentified + 1
		return "loadstring#" .. tostring(unidentified) 
	end)

	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	strFun = setfenv(strFun, fenv)

	return pcall(function()
		return GLUt.vararg_capture(strFun())
	end)
end

function GLUt.str_runlua_unsafe(source, chunkName)
	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	return pcall(function()
		return GLUt.vararg_capture()
	end)
end

function GLUt.kvp_tostring(k, v)
	return tostring(k) .. " = " .. tostring(v)
end

function GLUt.tbl_tryindex(tbl, ...)
	local indexing = tbl
	for _, k in GLUt.vararg_iter(...) do
		if GLUtCfg.type(indexing) ~= "table" then
			return false, indexing
		end
		indexing = indexing[tostring(k)]
	end

	return true, indexing
end

function GLUt.tbl_deepget(tbl, create_missing, ...)
	local indexing = tbl
	for i, k, n in GLUt.vararg_iter(...) do
		k = tostring(k)

		if indexing[k] == nil and create_missing then
			indexing[k] = {}
		end

		indexing = indexing[k]
		if GLUtCfg.type(indexing) ~= "table" and not (i == n) then
			return false, indexing, k
		end
	end

	return true, indexing
end

function GLUt.tbl_getkeys(tbl)
	local keys = {}
	for k, _ in pairs(tbl) do keys[#keys+1] = k end
	return keys
end

function GLUt.tbl_clone(tbl, shallow)
	shallow = GLUt.default(shallow, false)

	local cloned = {}
	for k, v in pairs(tbl) do
		if GLUtCfg.type(v) == "table" and not shallow then
			cloned[k] = GLUt.tbl_clone(v, shallow)
		else
			cloned[k] = v
		end
	end
	return cloned
end

function GLUt.tbl_merge(tbl1, tbl2, priority)
	priority = GLUt.default(priority, 1)
	local secondPriority = priority == 2
	local merged = {}
	for k, v in pairs(tbl1) do
		merged[k] = v
	end
	for k, v in pairs(tbl2) do
		local existing = merged[k]
		if GLUtCfg.type(existing) == "table" then
			merged[k] = GLUt.tbl_merge(existing, v, priority)
		elseif existing ~= nil and secondPriority then
			merged[k] = v
		elseif merged[k] == nil then
			merged[k] = v
		end
	end
	return merged
end

function GLUt.tbl_findsize(tbl)
	local i = 0
	for _, _ in pairs(tbl) do i = i + 1 end
	return i
end

local function tbl_tostring(tblName, tbl, levels, level)
	local str = tblName .. " = {"
	local indent = string.rep("  ", level)
	local n = GLUt.tbl_findsize(tbl)
	local i = 0
	for k, v in pairs(tbl) do
		i = i + 1
		str = str .. '\n' .. indent
		if GLUtCfg.type(v) == "table" and levels > level then
			str = str .. tbl_tostring(k, v, levels, level+1)
		else
			str = str .. GLUt.kvp_tostring(k, v)
		end
		if i < n then str = str .. ',' end
	end
	return str
end

function GLUt.tbl_tostring(tbl, levels, tblName)
	GLUt.default(tblName, tostring(tbl))
	return tbl_tostring(tblName, tbl, levels, 1)
end

function GLUt.tbl_any(tbl, f)
	local anySucceed = nil
	for k, v in pairs(tbl) do
		anySucceed = GLUt.default(anySucceed, false) or f(k, v)
		if anySucceed then break end
	end
	return anySucceed
end

function GLUt.tbl_all(tbl, f)
	local allSucceed = nil
	for k, v in pairs(tbl) do
		allSucceed = GLUt.default(allSucceed, true) and f(k, v)
		if not allSucceed then break end
	end
	return allSucceed
end

function GLUt.tbl_is_arr(tbl)
	local isArr = true
	for k, v in pairs(tbl) do
		isArr = isArr and GLUtCfg.type(k) == "number"
		if not isArr then break end
	end
	return isArr
end

local function tbl_arginfo(argType, name, index, expectedType)
	local typeStr = GLUt.type_is(expectedType, "string") and (" <T:" .. expectedType .. ">") or ""
	return argType .. " \"" .. name .. "\" (#" .. tostring(index) .. ")" .. typeStr 
end

local function tbl_argextract(fname, t, arglayout)
	local index = arglayout[1]
	local name = arglayout[2]
	local expectedType = arglayout[3]
	local canName = arglayout[4]
	local default = arglayout.Default or arglayout.default
	local vital = GLUt.default(arglayout.Vital or arglayout.vital, false)

	local tVal = t[index]
	if canName and tVal ~= nil then
		if t[name] ~= nil then
			return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo("Arg", name, index, expectedType) .. " passed both by name and index!")
		end
	elseif canName then
		tVal = t[name]
	end

	if tVal == nil and default ~= nil then
		tVal = default
	end

	if tVal == nil and expectedType == false then
		return nil
	elseif tVal == nil and not GLUt.str_has_match(expectedType, "%?") then
		local argType = vital and "Vital Arg" or "Arg"
		return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo(argType, name, index, expectedType) .. " not passed!")
	end

	if expectedType == false then return tVal end
	if not GLUt.type_check(tVal, expectedType, name, fname, true) then return nil end
	return tVal
end

function GLUt.fun_tblcallable(fname, f, ...)
	local n, callingConvention = GLUt.vararg_capture(...)
	return function(tbl)
		for k, v in pairs(tbl) do
			local isValid = false
			for i=1, n do
				if isValid then break end
				local validArg = callingConvention[i]
				isValid = (k == i) or (k == validArg[2])
			end
			if not isValid then
				GLUtCfg.error("Received unexpected argument \"" .. tostring(k) .. "\" of type \"" .. GLUtCfg.type(v) .. "\"!")
			end
		end
		local args = {}
		for i=1, n do
			local argLayout = callingConvention[i]
			args[i] = tbl_argextract(fname, tbl, argLayout)
		end
		return f(unpack(args, 1, n))
	end
end

return GLUt]]></ProtectedString>
				<string name="ScriptGuid">{34D0236F-E6C8-434F-B42D-6A8A80B1F6A8}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GLUt</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>